import pytest
import json
import logging as log

from assemblyline_v4_service.common.result import BODY_FORMAT
from .utils import hatching_result_instance


def test_build_malware_extract_dropper_sub_section(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the happy path. This validates both static and dynamic report scenarios.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and tags.
    """

    #
    # Validate from static report data
    #
    # Extract from a static analysis report: extracted[].dropper
    dropper = {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
        "urls": [{"type": "unk", "url": "https://test.local/d1"}],
    }

    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Dropper"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
        "urls.1.type": "unk",
        "urls.1.url": "https://test.local/d1",
    }

    assert section.heuristic.heur_id == 102
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.static.domain": ["test.local"],
        "network.static.uri": ["https://test.local/d1"],
        "network.static.uri_path": ["/d1"],
    }
    assert len(section.subsections) == 0

    #
    # Validate the same data, but when coming from a dynamic triage report
    #
    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=False
    )

    assert section is not None
    assert section.title_text == "Extracted Dropper"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
        "urls.1.type": "unk",
        "urls.1.url": "https://test.local/d1",
    }

    assert section.heuristic.heur_id == 102
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.dynamic.domain": ["test.local"],
        "network.dynamic.uri": ["https://test.local/d1"],
        "network.dynamic.uri_path": ["/d1"],
    }
    assert len(section.subsections) == 0


def test_when_val_in_body_but_no_tags_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that a Result is still created even though no tags are generated.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and NO tags.
    """

    dropper = {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
    }

    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Dropper"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
    }

    assert section.heuristic.heur_id == 102
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {}
    assert len(section.subsections) == 0


def test_tag_in_safelist_not_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that when a specific tag is in the safelist, it does not get generated when it otherwise would."""
    dropper = {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
        "urls": [{"type": "unk", "url": "https://test.local/d1"}],
    }

    hatching_result_instance.safelist = {
        "match": {"network.static.domain": ["test.local"]}
    }
    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Dropper"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "malfam",
        "language": "en",
        "source": "unk",
        "deobfuscated": "unk",
        "urls.1.type": "unk",
        "urls.1.url": "https://test.local/d1",
    }

    assert section.heuristic.heur_id == 102
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.static.uri": ["https://test.local/d1"],
        "network.static.uri_path": ["/d1"],
    }
    assert len(section.subsections) == 0


def test_returns_none(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the Result is returned as None when no data presented."""

    dropper = {}
    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )
    assert section is None

    dropper = None
    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )
    assert section is None


def test_result_section_key_value_uses_safe_vals(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that the key-value section data uses data that has been sanitized."""

    dropper = {
        "encoded": b"\xff\xfet\x00e\x00s\x00t\x00",
        "nested_dict": {
            "nested_key_1": "nested_key_1val",
            "nested_key_2": "nested_key_2val",
        },
        "list_of_dicts": [{"key1": "key1val"}, {"key2": "key2val"}],
        "list_of_strs": ["valA", "valB"],
    }

    # log.warning(mal_cfg)
    section = hatching_result_instance._build_malware_extract_dropper_sub_section(
        dropper=dropper, is_static_analysis=True
    )

    assert section is not None

    # Validate the byte vals are flattened and converted
    # log.warning(section.body)
    assert json.loads(section.body) == {
        "encoded": "\\xff\\xfet\\x00e\\x00s\\x00t\\x00",
        "nested_dict.nested_key_1": "nested_key_1val",
        "nested_dict.nested_key_2": "nested_key_2val",
        "list_of_dicts.1.key1": "key1val",
        "list_of_dicts.2.key2": "key2val",
        "list_of_strs": ["valA", "valB"],
    }
