import pytest
import json
import logging as log

from assemblyline_v4_service.common.result import BODY_FORMAT
from .utils import hatching_result_instance


def test_build_malware_extract_ransomnote_sub_section(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the happy path. This validates both static and dynamic report scenarios.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and tags.
    """

    #
    # Validate from static report data
    #
    # Extract from a static analysis report: extracted[].ransom_note
    ransom_note = {
        "emails": ["ta1@mransomware.local", "ta2@mransomware.local"],
        "note": "all your bases are belong to us",
        "urls": ["https://test.local/test", "https://test2.local"],
    }

    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Ransom Note"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "emails": ["ta1@mransomware.local", "ta2@mransomware.local"],
        "note": "all your bases are belong to us",
        "urls": ["https://test.local/test", "https://test2.local"],
    }

    assert section.heuristic.heur_id == 101
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.email.address": ["ta1@mransomware.local", "ta2@mransomware.local"],
        "network.static.domain": ["test.local", "test2.local"],
        "network.static.uri": ["https://test.local/test", "https://test2.local"],
        "network.static.uri_path": ["/test"],
    }
    assert len(section.subsections) == 0

    #
    # Validate the same data, but when coming from a dynamic triage report
    #
    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=False
    )

    assert section is not None
    assert section.title_text == "Extracted Ransom Note"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "emails": ["ta1@mransomware.local", "ta2@mransomware.local"],
        "note": "all your bases are belong to us",
        "urls": ["https://test.local/test", "https://test2.local"],
    }

    assert section.heuristic.heur_id == 101
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.email.address": ["ta1@mransomware.local", "ta2@mransomware.local"],
        "network.dynamic.domain": ["test.local", "test2.local"],
        "network.dynamic.uri": ["https://test.local/test", "https://test2.local"],
        "network.dynamic.uri_path": ["/test"],
    }
    assert len(section.subsections) == 0


def test_when_val_in_body_but_no_tags_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that a Result is still created even though no tags are generated.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and NO tags.
    """

    # Extract from a static analysis report: extracted[].config
    ransom_note = {
        "note": "all your bases are belong to us",
    }

    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Ransom Note"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    ransom_note = {
        "note": "all your bases are belong to us",
    }

    assert section.heuristic.heur_id == 101
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {}
    assert len(section.subsections) == 0


def test_tag_in_safelist_not_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that when a specific tag is in the safelist, it does not get generated when it otherwise would."""

    # Extract from a static analysis report: extracted[].ransom_note
    ransom_note = {
        "emails": ["ta1@mransomware.local"],
        "note": "all your bases are belong to us",
        "urls": ["https://test.local/test", "https://test2.local"],
    }

    hatching_result_instance.safelist = {
        "match": {"network.static.domain": ["test.local"]}
    }
    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Ransom Note"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "emails": ["ta1@mransomware.local"],
        "note": "all your bases are belong to us",
        "urls": ["https://test.local/test", "https://test2.local"],
    }

    assert section.heuristic.heur_id == 101
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.email.address": ["ta1@mransomware.local"],
        "network.static.domain": ["test2.local"],
        "network.static.uri": ["https://test.local/test", "https://test2.local"],
        "network.static.uri_path": ["/test"],
    }
    assert len(section.subsections) == 0


def test_returns_none(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the Result is returned as None when no data presented."""

    ransom_note = {}
    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )
    assert section is None

    ransom_note = None
    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )
    assert section is None


def test_result_section_key_value_uses_safe_vals(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that the key-value section data uses data that has been sanitized."""

    ransom_note = {
        "encoded": b"\xff\xfet\x00e\x00s\x00t\x00",
        "nested_dict": {
            "nested_key_1": "nested_key_1val",
            "nested_key_2": "nested_key_2val",
        },
        "list_of_dicts": [{"key1": "key1val"}, {"key2": "key2val"}],
        "list_of_strs": ["valA", "valB"],
    }

    # log.warning(mal_cfg)
    section = hatching_result_instance._build_malware_extract_ransomnote_sub_section(
        ransom_note=ransom_note, is_static_analysis=True
    )

    assert section is not None

    # Validate the byte vals are converted
    # log.warning(section.body)
    assert json.loads(section.body) == {
        "encoded": "\\xff\\xfet\\x00e\\x00s\\x00t\\x00",
        "nested_dict.nested_key_1": "nested_key_1val",
        "nested_dict.nested_key_2": "nested_key_2val",
        "list_of_dicts.1.key1": "key1val",
        "list_of_dicts.2.key2": "key2val",
        "list_of_strs": ["valA", "valB"],
    }
