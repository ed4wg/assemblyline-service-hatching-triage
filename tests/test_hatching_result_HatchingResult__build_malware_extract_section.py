"""Validate the this function that creates a Malware Extract Section with multiple sub-sections.
The individual methods that build each sub-section has more thorough unit tests for each sub-section's capabilities.
"""
import pytest
import json
import logging as log

from assemblyline_v4_service.common.result import BODY_FORMAT
from .utils import hatching_result_instance


def test_build_malware_extract_section(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the happy path.

    Validate a ResultSection is created with sub-sections for each of the 4 extracted config types.
        malware config, credentials, dropper, ransom note
    """

    # A minimized/fake set of results to validate all sections show up
    extracted_items = [
        {
            "config": {
                "c2": ["1.3.3.7:4433"],
            }
        },
        {
            "credentials": {
                "username": "user1",
                "password": "mypass",
            }
        },
        {
            "dropper": {
                "family": "malfam",
            }
        },
        {
            "ransom_note": {
                "note": "all your bases are belong to us",
            }
        },
    ]

    section = hatching_result_instance._build_malware_extract_section(
        extracted_items=extracted_items, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Items"
    assert section.body_format == BODY_FORMAT.TEXT
    assert section.body == None
    assert section.heuristic == None
    assert section.tags == {}

    # Validate all sub-sections present.
    assert len(section.subsections) == 4

    expected_subs = [
        "Extracted Malware Config",
        "Extracted Credentials",
        "Extracted Dropper",
        "Extracted Ransom Note",
    ]

    for sub_sec in section.subsections:
        assert sub_sec.title_text in expected_subs


def test_single_extract_type(
    hatching_result_instance: hatching_result_instance,
):
    """Validate a ResultSection is created with just a single sub-section when only a single eligible extrat type is
    present.
    """

    # A minimized/fake set of results to for just creds
    extracted_items = [
        {
            "credentials": {
                "username": "user1",
                "password": "mypass",
            }
        },
    ]

    section = hatching_result_instance._build_malware_extract_section(
        extracted_items=extracted_items, is_static_analysis=False
    )

    assert section is not None
    assert section.title_text == "Extracted Items"
    assert section.body_format == BODY_FORMAT.TEXT
    assert section.body == None
    assert section.heuristic == None
    assert section.tags == {}

    # Validate all sub-sections present.
    assert len(section.subsections) == 1

    expected_subs = [
        "Extracted Credentials",
    ]

    for sub_sec in section.subsections:
        assert sub_sec.title_text in expected_subs


def test_returns_none(
    hatching_result_instance: hatching_result_instance,
):
    """Validate nothing is returned when there are no eligible extracted types in the input."""
    extracted_items = []
    section = hatching_result_instance._build_malware_extract_section(
        extracted_items=extracted_items, is_static_analysis=False
    )
    assert section is None

    extracted_items = None
    section = hatching_result_instance._build_malware_extract_section(
        extracted_items=extracted_items, is_static_analysis=False
    )
    assert section is None

    # Validate when no eligible type present in the extract data
    # A fake set of results to validate all sections show up
    extracted_items = [
        {
            "dumped_file": "out.upx",
            "resource": "static1/unpack001/out.upx",
        },
    ]
    section = hatching_result_instance._build_malware_extract_section(
        extracted_items=extracted_items, is_static_analysis=False
    )
    assert section is None
