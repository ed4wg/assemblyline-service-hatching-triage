import pytest
import json
import logging as log

from assemblyline_v4_service.common.result import BODY_FORMAT
from .utils import hatching_result_instance


def test_build_malware_extract_config_sub_section(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the happy path. This validates both static and dynamic report scenarios.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and tags.
    """

    #
    # Validate from static report data
    #
    # Extract from a static analysis report: extracted[].config
    mal_cfg = {
        "family": "metasploit",
        "rule": "Metasploit",
        "c2": ["1.3.3.7:4433"],
        "version": "windows/shell_reverse_tcp",
        "dns": ["1.3.3.8"],
        "listen_addr": "1.3.3.9",
        "listen_port": 3221,
        "command_lines": [
            "cmd.exe /c rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 720 C:\\ProgramData\\lsass.dmp full",
            "bcdedit  /set {default} recoveryenabled no",
        ],
    }

    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Malware Config"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "metasploit",
        "rule": "Metasploit",
        "c2": ["1.3.3.7:4433"],
        "version": "windows/shell_reverse_tcp",
        "dns": ["1.3.3.8"],
        "listen_addr": "1.3.3.9",
        "listen_port": 3221,
        "command_lines": [
            "cmd.exe /c rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 720 C:\\ProgramData\\lsass.dmp full",
            "bcdedit  /set {default} recoveryenabled no",
        ],
    }

    assert section.heuristic.heur_id == 100
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {
        "network.static.ip": ["1.3.3.7", "1.3.3.8", "1.3.3.9"],
        "network.port": ["4433", 3221],
        "dynamic.process.command_line": [
            "cmd.exe /c rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 720 C:\\ProgramData\\lsass.dmp full",
            "bcdedit  /set {default} recoveryenabled no",
        ],
    }
    assert len(section.subsections) == 0

    #
    # Validate the same data, but when coming from a dynamic triage report
    #
    hatching_result_instance.safelist = {}

    # Reusing the same data for dynamic triage reports
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=False
    )

    assert section is not None
    assert section.title_text == "Extracted Malware Config"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    assert json.loads(section.body) == {
        "family": "metasploit",
        "rule": "Metasploit",
        "c2": ["1.3.3.7:4433"],
        "version": "windows/shell_reverse_tcp",
        "dns": ["1.3.3.8"],
        "listen_addr": "1.3.3.9",
        "listen_port": 3221,
        "command_lines": [
            "cmd.exe /c rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 720 C:\\ProgramData\\lsass.dmp full",
            "bcdedit  /set {default} recoveryenabled no",
        ],
    }

    assert section.heuristic.heur_id == 100
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # network.dynamic.ip tag instead
    # log.warning(section.tags)
    assert section.tags == {
        "network.dynamic.ip": ["1.3.3.7", "1.3.3.8", "1.3.3.9"],
        "network.port": ["4433", 3221],
        "dynamic.process.command_line": [
            "cmd.exe /c rundll32.exe C:\\windows\\System32\\comsvcs.dll, MiniDump 720 C:\\ProgramData\\lsass.dmp full",
            "bcdedit  /set {default} recoveryenabled no",
        ],
    }
    assert len(section.subsections) == 0


def test_when_val_in_body_but_no_tags_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that a Result is still created even though no tags are generated.

    A ResultKeyValueSection is created with the appropriate key-values, associated heuristic, and NO tags.
    """

    # Extract from a static analysis report: extracted[].config
    mal_cfg = {"family": "ramnit", "rule": "Ramnit"}

    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )

    assert section is not None
    assert section.title_text == "Extracted Malware Config"
    assert section.body_format == BODY_FORMAT.KEY_VALUE

    # log.warning(section.body)
    assert json.loads(section.body) == {
        "family": "ramnit",
        "rule": "Ramnit",
    }

    assert section.heuristic.heur_id == 100
    assert section.heuristic.attack_ids == []
    assert section.heuristic.signatures == {}
    assert section.heuristic.score == 1000

    # log.warning(section.tags)
    assert section.tags == {}
    assert len(section.subsections) == 0


def test_tag_in_safelist_not_generated(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that when a specific tag is in the safelist, it does not get generated when it otherwise would."""

    # Extract from a static analysis report: extracted[].config
    mal_cfg = {
        "family": "metasploit",
        "rule": "Metasploit",
        "c2": ["1.3.3.7:4433"],
        "version": "windows/shell_reverse_tcp",
    }

    hatching_result_instance.safelist = {"match": {"network.static.ip": ["1.3.3.7"]}}
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )
    assert section is not None
    assert section.tags == {"network.port": ["4433"]}

    # Now clear out the safelist and validate the tag is generated
    hatching_result_instance.safelist = {}
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )
    assert section is not None
    assert section.tags == {"network.static.ip": ["1.3.3.7"], "network.port": ["4433"]}
    assert len(section.subsections) == 0


def test_returns_none(
    hatching_result_instance: hatching_result_instance,
):
    """Validate the Result is returned as None when no data presented."""

    mal_cfg = {}
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )
    assert section is None

    mal_cfg = None
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )
    assert section is None


def test_result_section_key_value_uses_safe_vals(
    hatching_result_instance: hatching_result_instance,
):
    """Validate that the key-value section data uses data that has been flattened and sanitized."""

    # Extract from a static analysis report: extracted[].config
    mal_cfg = {
        "encoded": b"\xff\xfet\x00e\x00s\x00t\x00",
        "nested_dict": {
            "nested_key_1": "nested_key_1val",
            "nested_key_2": "nested_key_2val",
        },
        "list_of_dicts": [{"key1": "key1val"}, {"key2": "key2val"}],
        "list_of_strs": ["valA", "valB"],
    }

    # log.warning(mal_cfg)
    section = hatching_result_instance._build_malware_extract_config_sub_section(
        malware_config=mal_cfg, is_static_analysis=True
    )

    assert section is not None

    # Validate the byte vals are flattened and converted
    # log.warning(section.body)
    assert json.loads(section.body) == {
        "encoded": "\\xff\\xfet\\x00e\\x00s\\x00t\\x00",
        "nested_dict.nested_key_1": "nested_key_1val",
        "nested_dict.nested_key_2": "nested_key_2val",
        "list_of_dicts.1.key1": "key1val",
        "list_of_dicts.2.key2": "key2val",
        "list_of_strs": ["valA", "valB"],
    }
